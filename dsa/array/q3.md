
In the shadowy circuits of the hacker underworld, data isn't just stored, it's encoded with secrets. Among the lines of encrypted entries lies an array of codes (represented by positive integers), each one a digital fingerprint. Within this set, certain code-pairs appear nearly identical, save for a subtle corruption in a single digit. You've intercepted this array, and your mission is to uncover how many unique index-pairs (i, j) exist such that o si<j< codes.length, where the codes are exactly the same length, but differ in precisely one digit.
Example
For codes = [404, 12, 504, 7, 414, 604, 700, 1], the output should be solution (codes)
<<
= 5
codes [0] = 404 differs from codes [2]
= 504 in the first digit.
codes [0] = 404 codes [0] = 404
differs from differs from
codes [4] = 414
in the second digit.
codes [5] = 604
in the first digit.
codes [2] = 504
differs from
codes [5] = 604 in the first digit.
codes [3] = 7 differs from codes [7] = 1 in their only digit.
Only pairs with the same number of digits are considered. For example:
codes [0]= 404 and codes [1]= 12 are ignored, since they have different lengths (3) vs 2).
Input/Output
[execution time limit] 5 seconds (ts)
[memory limit] 1 GB
[input] array.integer codes
The array holds positive integers, each one a shard of hidden knowledge.
Guaranteed constraints: