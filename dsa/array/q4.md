
You start at the upper-left corner cell with coordinates (0, 0), and the goal is to reach the exit<<< located at the cell with coordinates (n 1, m - 1). You move according to the following
rules:
-
• You will always move to the right: if you're currently on the cell with coordinates (row, col), you will try moving to the cell with coordinates (row, col + 1).
• If you move to a cell that is the starting point of a teleport, proceed to the coordinates of the end cell.
• If you try to move to a cell that contains an obstacle, stop moving and stay where you are.
• If you try to move to a cell that is outside the bounds of the labyrinth, move to the beginning of the next row instead - cell with coordinates (row + 1, 0). If that cell contains an obstacle, follow the obstacle rule above.
Your task is to check whether you can reach the goal (exit of the labyrinth) by following the algorithm above, and to return the total number of cells you travelled through to reach the exit. Note that you should count all cells travelled, including the starting cell (0, 0), and both the start and end cells of all teleports. If it is not possible to reach the exit, return -1 if it's because of an obstacle, or -2 if it's because of teleportation (i.e., an infinite teleport loop).
It's guaranteed that the starting cell (0, 0) and the exit cell (n-1, m an obstacle, or be the starting point of a teleport.
-
1) do not contain
Note: You are not expected to provide the most optimal solution, but a solution with time
complexity not worse than o (n
m
(obstacles.length + teleports.length) will fit within
the execution time limit.
Example
=
• For n = 3 m = 3, obstacles [[2, 1]], and teleports = [[0, 1, 2, 011, the output should be solution (n, m, obstacles, teleports)
= -1
▼Expand to see the example video.